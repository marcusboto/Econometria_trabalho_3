title: "Trabalho Econometria"
author: "Pedro Affonso Ferreira Latini, Marcus Vinicius Rocha Boto"
date: "2025-12-06"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
source("code/_master.R")
```

## Introdução

  Neste arquivo markdown iremos responder a terceira questão do trabalho, gerado a partir do arquivo smallmo.dta fornecido pelo professor.

##  Questão 3 

Como sugestão do professor, utilizamos o comando pacman para instalar e gerenciar pacotes, ele está disponível na subpasta code. Todos os outros códigos, com respectiva identificação da questão também estão lá.

```{r Lib}
library(readstata13)
library  (dplyr)        
library (ggplot2)      
library  (stargazer)    
library (AER)          
library  (lmtest)       
library  (sandwich)     
library  (broom)
library  (tidyr)
```

### 3.1 - Características da Amostra e Estatísticas Descritivas

```{r Char, cache=TRUE, results='asis'}



Maimonides_italia <- read.dta13(file.path("input/smallmo.dta")) #Usa read.ddta13 para ober dados a partir do input

variaveis_descritivas <- Maimonides_italia %>% #Escolhe as estatísticas designadas
  select(
    answers_math_std,    
    answers_ital_std,    
    female,              
    immigrants_broad,    
    dad_lowedu,          
    dad_midedu,          
    mom_unemp,           
    answers_math_pct,    
    answers_ital_pct,    
    our_CHEAT_ital,      
    our_CHEAT_math       
  )

stargazer(variaveis_descritivas,  #USA PACOTE STARGAZER PARA GERAR A TABELA
          type = "html",
          title = "Estatísticas Descritivas - Dados Italianos",
          digits = 3,
          covariate.labels = c(
            "Nota Padronizada - Matemática",
            "Nota Padronizada - Italiano",
            "Sexo Feminino (Dummy)",
            "Imigrante (Dummy)",
            "Pai com Baixa Educação",
            "Pai com Educação Média", 
            "Mãe Desempregada",
            "Percentil - Matemática",
            "Percentil - Italiano",
            "Indício Manipulação - Italiano",
            "Indício Manipulação - Matemática"
          ),
          summary.stat = c("n", "mean", "median", "sd", "min", "max"),
          out = file.path(output, "questao3_1_estatisticas_descritivas.html"))

```
### 3.2 - Cálculo de médias de variáveis por região italiana e série

```{r Medias, cache=TRUE, results='asis'}



medias_por_regiao_serie <- Maimonides_italia %>% #Calcula usando pacote dplyr
  group_by(area, grade) %>%
  summarise(
    media_answers_math_std = mean(answers_math_std, na.rm = TRUE),
    media_answers_ital_std = mean(answers_ital_std, na.rm = TRUE),
    media_female = mean(female, na.rm = TRUE),
    media_immigrants_broad = mean(immigrants_broad, na.rm = TRUE),
    media_dad_lowedu = mean(dad_lowedu, na.rm = TRUE),
    media_dad_midedu = mean(dad_midedu, na.rm = TRUE),
    media_mom_unemp = mean(mom_unemp, na.rm = TRUE),
    media_answers_math_pct = mean(answers_math_pct, na.rm = TRUE),
    media_answers_ital_pct = mean(answers_ital_pct, na.rm = TRUE),
    media_our_CHEAT_ital = mean(our_CHEAT_ital, na.rm = TRUE),
    media_our_CHEAT_math = mean(our_CHEAT_math, na.rm = TRUE)
  )


stargazer(medias_por_regiao_serie, #Tabela Stargazer
          type = "html",
          title = "Médias por região e série",
          summary = FALSE,
          rownames = FALSE,
          digits = 2,
          out = "output/tabela_medias.html")  # salva em output


```
### 3.3 - Aleatorização

  O balanceamento é importante pois precisamos garandir que os grupos de tratamento e controle tenham sido bem randomizados. Caso isso não acontece, ou seja características dos grupos sejam muito diferentes, estamos comprometendo o experimento, uma vez que as diferenças observadas podem ser atribuídas a estas características diferentes, e não ao experimento em si (tratamento x controle).

  Uma boa variável que devemos observar o balanceamento é a immigrants_broad, que indica o percentual de estudantes imigrantes nas escolas. Ela é fundamental pois ser imigrante introduz dificuldades de aprendizado por falta de domínio do idioma nativo, além de possível discriminação.
  
### 3.4 - Balanceamento

```{r Balance, cache=TRUE, results='asis'}

varie <- c("female", "immigrants_broad", "dad_lowedu", "dad_midedu", "mom_unemp") #Variáveis escolhidas

resultados_balanceamento <- data.frame(
  Variavel = character(),
  Media_Tratamento = numeric(),
  Media_Controle = numeric(),
  Diferenca = numeric(),
  p_valor = numeric(),
  stringsAsFactors = FALSE
)

for (var in varie) {
  tratamento <- Maimonides_italia[[var]][Maimonides_italia$o_math == 1]
  controle <- Maimonides_italia[[var]][Maimonides_italia$o_math == 0]
  
  teste <- t.test(tratamento, controle)
  
  resultados_balanceamento <- rbind(resultados_balanceamento, 
                                    data.frame(
                                      Variavel = var,
                                      Media_Tratamento = mean(tratamento, na.rm = TRUE),
                                      Media_Controle = mean(controle, na.rm = TRUE),
                                      Diferenca = teste$estimate[1] - teste$estimate[2],
                                      p_valor = teste$p.value
                                    ))
}

```

### 3.5 - Balanceamento via Regressão

```{r Regs, cache=TRUE, results='asis'}

# 1. Regressão simples

reg1 <- lm(mom_unemp ~ o_math, data = Maimonides_italia)
reg1_cluster <- coeftest(reg1,
                         vcov = vcovCL(reg1, cluster = Maimonides_italia$CLUSTER))

# 2. Regressão com controles
reg2 <- lm(mom_unemp ~ o_math + female + immigrants_broad +
             dad_lowedu + dad_midedu,
           data = Maimonides_italia)

reg2_cluster <- coeftest(reg2,
                         vcov = vcovCL(reg2, cluster = Maimonides_italia$CLUSTER))
# 3. Regressão com efeitos fixos
###############################################################
reg3 <- lm(mom_unemp ~ o_math + factor(area),
           data = Maimonides_italia)

reg3_cluster <- coeftest(reg3,
                         vcov = vcovCL(reg3, cluster = Maimonides_italia$CLUSTER))

# 4. Interação

reg4 <- lm(mom_unemp ~ o_math + factor(area) * enrol_ins_snv,
           data = Maimonides_italia)

reg4_cluster <- coeftest(reg4,
                         vcov = vcovCL(reg4, cluster = Maimonides_italia$CLUSTER))

# 5. Tabela HTML
stargazer(reg1, reg2, reg3, reg4,
          type = "html",
          out = "balanceamento_ex35.html",
          title = "output/Exercício 3.5 — Balanceamento")


```
### 3.6 - Monitoramento Regional

```{r MonReg, cache=TRUE, results='asis'}
# Variável Dependente:
VD <- "our_CHEAT_ital"

reg_interacao_fraude <- lm(
  as.formula(paste(VD, "~ o_math * factor(area) + factor(grade)")),
  data = Maimonides_italia,
  na.action = na.omit
)

# Geração da Tabela Stargazer
stargazer(reg_interacao_fraude,
          type = "html", # Altere para "latex" para Overleaf
          title = "Impacto do Monitoramento sobre a Fraude: Análise de Interação Regional",
          dep.var.labels = c("Fraude em Italiano"),
          # Nota: Os labels para as interações são gerados automaticamente pelo R.
          covariate.labels = c("Monitoramento (Norte Ref.)", 
                               "Região Central (Nível Base)", "Região Sul (Nível Base)",
                               "Série (Grade 2)", "Série (Grade 3)", "Série (Grade 4)",
                               "Interação: Monit. x Centro", "Interação: Monit. x Sul"),
          out = "monitoramento_regional_interacao.html",
          add.lines = list(c("Referência Regional", "Norte"),
                           c("Referência de Série", "Grade 1")),
          digits = 4)

```
### 3.7 - Notas Regionais

```{r NotReg, cache=TRUE, results='asis'}

# Variável Dependente
VD <- "answers_math_std"

Maimonides_italia <- Maimonides_italia %>%
  mutate(is_sul = ifelse(area == 3, 1, 0)) # 1 se for Sul, 0 caso contrário

reg_interacao_notas <- lm(
  answers_math_std ~ o_math * is_sul + factor(area) + factor(grade),
  data = Maimonides_italia,
  na.action = na.omit
)

# Geração da Tabela Stargazer
stargazer(reg_interacao_notas,
          type = "html", # Altere para "latex" para Overleaf
          title = "Impacto do Monitoramento nas Notas: Efeito Diferencial no Sul",
          dep.var.labels = c("Nota de Matemática (Std)"),
          # Nota: O termo de interação 'o_math:is_sul' é o coeficiente chave (delta 1).
          covariate.labels = c("Monitoramento (Norte Ref.)", 
                               "Sul (Dummy de Nível)", 
                               "Região Central (Dummy)", "Região Sul (Dummy - Base)", # Dummies da área
                               "Série (Grade 2)", "Série (Grade 3)", "Série (Grade 4)",
                               "Interação: Monit. x Sul (Diferença)"),
          out = "notas_regional_interacao.html",
          add.lines = list(c("Referência Regional", "Norte"),
                           c("Referência de Série", "Grade 1")),
          digits = 4)
```
### 3.8 - Tamanho da Turma

 O problema de rodar uma regressão OLS simples das notas (answers_math_std) no tamanho da turma (clsize_snv) é a Endogeneidade, o que leva a um viés de variável omitida e/ou viés de seleção.

#### Viés de Variável Omitida:

  O tamanho da turma não é atribuído aleatoriamente. Fatores não observáveis que afetam a nota também influenciam o tamanho da turma, gerando correlação entre o regressor (Tamanho da Turma) e o termo de erro.

#### Exemplo (Viés de Seleção): 

  Diretores podem intencionalmente alocar alunos com necessidades especiais ou baixo desempenho em turmas menores. Neste caso, a correlação entre Tamanho da Turma e termo de erro é positiva (turmas menores estão associadas a fatores negativos não observados), o que leva a uma subestimação do benefício de turmas menores. O OLS indicaria que turmas menores têm notas piores, quando na verdade, o problema é a qualidade inicial dos alunos alocados lá.

### 3.9 - Maimônides

  A Regra de Maimônides (ou qualquer regra de limite/teto) é crucial porque resolve o problema de Endogeneidade presente na regressão OLS simples. Ela transforma a variação no tamanho da turma de uma decisão endógena da escola para uma variação exógena no ponto de corte.

#### Importância para o Efeito Causal (RDD):

  A regra estipula que, se a matrícula ultrapassar um limite (cutoff), a turma deve ser dividida em duas. Por exemplo, na regra antiga italiana, se a matrícula for acima de 25 (ou 28, considerando a tolerância ), uma nova turma é aberta, forçando o tamanho médio da turma para baixo.

#### Identificação: 
  
  Um aluno que mal perde o corte (matrícula de 26) é muito semelhante a um aluno que mal o ultrapassa (matrícula de 25) em termos de características não observáveis. No entanto, o aluno do grupo de 26 alunos será alocado em uma turma menor devido à regra, enquanto o aluno do grupo de 25 permanecerá em uma turma maior.

#### Efeito Causal: 

Ao comparar o resultado (nota) dos alunos logo acima e logo abaixo do limite (o cutoff), a única coisa que muda abruptamente é o tamanho predito da turma. Isso permite que a diferença na nota seja atribuída causalmente à mudança forçada no tamanho da turma.

#### Hipóteses Necessárias para o RDD:

  Para que o RDD (Regressão de Descontinuidade) funcione e recupere o efeito causal do tamanho da turma, duas hipóteses principais devem ser satisfeitas:

 1) Continuidade	A relação funcional entre a variável de atribuição (matrícula) e o resultado (nota) é contínua em torno do corte. Não deve haver saltos na nota ou nas características do aluno exceto pela intervenção do tratamento (a abertura da nova turma).
 
 2) Não Manipulação do Corte: Os indivíduos (neste caso, escolas ou diretores) não devem ser capazes de manipular perfeitamente a variável de atribuição (matrícula) para serem alocados no lado mais vantajoso do corte. Se a manipulação for grosseira, o desenho falha, pois a alocação não é mais "quase aleatória" perto do limite.
 
### 3.10 -  RDD

```{R, cache=TRUE, results='asis'}


# 1. Pela regra italiana (serão nossos cutoffs)
cutoff_baixo <- 22  # Financia turma adicional
cutoff_alto <- 28   # Exige nova turma

# 2. Criar categorias
Maimonides_italia <- Maimonides_italia %>%
  mutate(
    categoria = case_when(
      clsize_hat < cutoff_baixo ~ "Abaixo de 22",
      clsize_hat >= cutoff_baixo & clsize_hat < cutoff_alto ~ "Entre 22 e 28",
      clsize_hat >= cutoff_alto ~ "28 ou mais"
    ),
    # Dummy
    acima_22 = ifelse(clsize_hat >= cutoff_baixo, 1, 0),
    acima_28 = ifelse(clsize_hat >= cutoff_alto, 1, 0)
  )

# 3. Scatterplot agrupado
dados_plot <- Maimonides_italia %>%
  filter(!is.na(categoria)) %>%
  group_by(clsize_hat, categoria) %>%
  summarise(
    mean_score = mean(answers_math_std, na.rm = TRUE),
    n_obs = n(),
    .groups = "drop"
  )

# 4. Regressões para cada segmento
# Segmento 1: Abaixo de 22
reg_abaixo22 <- lm(answers_math_std ~ clsize_hat,
                   data = Maimonides_italia %>% 
                     filter(categoria == "Abaixo de 22"))

# Segmento 2: Entre 22 e 28
reg_entre22_28 <- lm(answers_math_std ~ clsize_hat,
                     data = Maimonides_italia %>% 
                       filter(categoria == "Entre 22 e 28"))

# 5. Linhas previstas para cada segmento
# Abaixo de 22
x_abaixo <- seq(min(dados_plot$clsize_hat[dados_plot$categoria == "Abaixo de 22"]),
                cutoff_baixo - 0.1,
                length.out = 100)
pred_abaixo <- data.frame(clsize_hat = x_abaixo)
pred_abaixo$pred <- predict(reg_abaixo22, newdata = pred_abaixo)

# Entre 22 e 28
x_entre <- seq(cutoff_baixo,
               cutoff_alto - 0.1,
               length.out = 100)
pred_entre <- data.frame(clsize_hat = x_entre)
pred_entre$pred <- predict(reg_entre22_28, newdata = pred_entre)

# 28 ou mais (se houver dados)
if (sum(Maimonides_italia$categoria == "28 ou mais", na.rm = TRUE) > 5) {
  x_acima <- seq(cutoff_alto,
                 max(dados_plot$clsize_hat[dados_plot$categoria == "28 ou mais"]),
                 length.out = 100)
  pred_acima <- data.frame(clsize_hat = x_acima)
  pred_acima$pred <- predict(reg_acima28, newdata = pred_acima)
} else {
  pred_acima <- NULL
}

# 6. Gráfico completo
p <- ggplot() +
  # Pontos coloridos por categoria
  geom_point(data = dados_plot,
             aes(x = clsize_hat, y = mean_score, color = categoria, size = n_obs),
             alpha = 0.5) +
  
  # Linhas de regressão para cada segmento
  geom_line(data = pred_abaixo, aes(x = clsize_hat, y = pred),
            color = "#1f77b4", size = 1.2) +  # Azul
  
  geom_line(data = pred_entre, aes(x = clsize_hat, y = pred),
            color = "#ff7f0e", size = 1.2) +  # Laranja
  
  # Linhas verticais dos cutoffs
  geom_vline(xintercept = c(cutoff_baixo, cutoff_alto),
             linetype = "dashed", size = 1, alpha = 0.7) +
  
  # Anotações dos cutoffs
  annotate("text", x = cutoff_baixo, y = max(dados_plot$mean_score),
           label = "Cutoff = 22\n(Financia turma adicional)",
           hjust = 1.1, vjust = 1, size = 3.5, fontface = "bold") +
  
  annotate("text", x = cutoff_alto, y = max(dados_plot$mean_score),
           label = "Cutoff = 28\n(Exige nova turma)",
           hjust = -0.1, vjust = 1, size = 3.5, fontface = "bold") +
  
  # Linha para acima de 28 (se existir)
  if (!is.null(pred_acima)) {
    p <- p + geom_line(data = pred_acima, aes(x = clsize_hat, y = pred),
                       color = "#2ca02c", size = 1.2)  # Verde
  }

# Estética
labs(title = "RDD com Múltiplos Cutoffs: Notas vs Tamanho Predito",
     subtitle = "Regra italiana: cutoff em 22 (financiamento) e 28 (obrigatório)",
     x = "Tamanho Predito da Classe (clsize_hat)",
     y = "Nota média padronizada (answers_math_std)",
     color = "Faixa de tamanho",
     size = "Nº de observações") +
  scale_color_manual(values = c("Abaixo de 22" = "#1f77b4",
                                "Entre 22 e 28" = "#ff7f0e",
                                "28 ou mais" = "#2ca02c")) +
  scale_size_continuous(range = c(1, 4)) +
  theme_minimal() +
  theme(legend.position = "bottom",
        plot.title = element_text(face = "bold", size = 14),
        plot.subtitle = element_text(size = 11))

print(p)

# 7. Resultados das regressões
cat("\n=== RESULTADOS DAS REGRESSÕES POR SEGMENTO ===\n")

cat("\n1. ABAIXO DE 22:\n")
print(summary(reg_abaixo22))

cat("\n2. ENTRE 22 E 28:\n")
print(summary(reg_entre22_28))

cat("\n3. 28 OU MAIS:\n")
if (exists("reg_acima28") && !is.null(reg_acima28)) {
  print(summary(reg_acima28))
} else {
  cat("Poucas observações para estimar\n")
}

# 8. Estatísticas descritivas por categoria
cat("\n=== ESTATÍSTICAS POR CATEGORIA ===\n")
stats_categorias <- Maimonides_italia %>%
  group_by(categoria) %>%
  summarise(
    n = n(),
    media_nota = mean(answers_math_std, na.rm = TRUE),
    media_tamanho = mean(clsize_hat, na.rm = TRUE),
    .groups = "drop"
  )
print(stats_categorias)

# 9. Salvar gráfico
ggsave("output/rdd_multiplos_cutoffs.png", p, width = 11, height = 7, dpi = 300)
```
###3.11 - Predição

  Obtemos uma medida mais adequada para identificar a relação causal entre Tamanho da turma e desempenho dos alunos. O clsize_hat é determinado exclusivamente pela Regra de Maimônides, que define o tamanho máximo das classes e gera uma divisão mecânica das turmas quando o número de alunos ultrapassa o cutoff. Essa regra produz uma variação exógena no tamanho predito, funcionando como um instrumento quase-aleatório. Por isso, o clsize_hat é apropriado para um desenho RDD e para inferência causal.

  Já o tamanho real das turmas pode ser endógeno: escolas podem ajustar turmas menores para alunos mais fracos, distribuir professores melhores em classes específicas ou reorganizar salas de acordo com recursos, perfil socioeconômico ou desempenho esperado. Assim, o tamanho real pode estar correlacionado com variáveis não observadas (qualidade da escola, habilidade dos alunos, SES, etc.), gerando viés de variável omitida.

  Portanto, o uso do tamanho predito (clsize_hat) reduz problemas de endogeneidade e é mais adequado para estimar a relação causal no RDD.

```{r pred, cache=TRUE, results='asis'}

CUTOFF_BAIXO <- 22  # Financia turma adicional
CUTOFF_ALTO <- 28   # Exige nova turma

# 1. Criar variável com duas categorias
Maimonides_italia <- Maimonides_italia %>%
  mutate(
    categoria = case_when(
      clsize_hat < CUTOFF_BAIXO ~ "Abaixo de 22",
      clsize_hat >= CUTOFF_BAIXO & clsize_hat < CUTOFF_ALTO ~ "Entre 22 e 28",
    )
  )

# 2. Scatterplot agrupado
dados_plot <- Maimonides_italia %>%
  group_by(clsize_hat) %>%
  summarise(
    mean_score = mean(answers_math_std, na.rm = TRUE),
    categoria = first(categoria),
    .groups = "drop"
  )

# 3. Regressões para CADA segmento

# Segmento 1: Abaixo de 22
if (sum(Maimonides_italia$categoria == "Abaixo de 22", na.rm = TRUE) > 10) {
  reg_abaixo22 <- lm(answers_math_std ~ clsize_hat,
                     data = Maimonides_italia %>% 
                       filter(categoria == "Abaixo de 22"))
} else {
  reg_abaixo22 <- NULL
}

# Segmento 2: Menor que 28
if (sum(Maimonides_italia$categoria == "Entre 22 e 28", na.rm = TRUE) > 10) {
  reg_entre22_28 <- lm(answers_math_std ~ clsize_hat,
                       data = Maimonides_italia %>% 
                         filter(categoria == "Entre 22 e 28"))
} else {
  reg_entre22_28 <- NULL

}

# 4. LINHAS DE PREDIÇÃO (FALTANDO NO SEU CÓDIGO)
# Abaixo de 22
if (!is.null(reg_abaixo22)) {
  linha_abaixo <- data.frame(
    clsize_hat = seq(
      min(dados_plot$clsize_hat[dados_plot$categoria == "Abaixo de 22"]),
      CUTOFF_BAIXO - 0.1,
      length.out = 100
    )
  )
  linha_abaixo$pred <- predict(reg_abaixo22, newdata = linha_abaixo)
} else {
  linha_abaixo <- NULL
}

# Menor que 28
if (!is.null(reg_entre22_28)) {
  linha_entre <- data.frame(
    clsize_hat = seq(
      CUTOFF_BAIXO,
      CUTOFF_ALTO - 0.1,
      length.out = 100
    )
  )
  linha_entre$pred <- predict(reg_entre22_28, newdata = linha_entre)
} else {
  linha_entre <- NULL
}


# 5. Gráfico com DOIS cutoffs
p <- ggplot() +
  # Pontos coloridos por categoria
  geom_point(data = dados_plot,
             aes(x = clsize_hat, y = mean_score, color = categoria),
             alpha = 0.5, size = 2) +
  
  # Linhas verticais dos DOIS cutoffs
  geom_vline(xintercept = c(CUTOFF_BAIXO, CUTOFF_ALTO),
             linetype = "dashed", size = 1, alpha = 0.7, color = "gray50") +
  
  # Anotações
  annotate("text", x = CUTOFF_BAIXO, y = max(dados_plot$mean_score),
           label = "Cutoff = 22", hjust = 1.1, vjust = 1, 
           size = 4, fontface = "bold") +
  
  annotate("text", x = CUTOFF_ALTO, y = max(dados_plot$mean_score),
           label = "Cutoff = 28", hjust = -0.1, vjust = 1,
           size = 4, fontface = "bold") +
  
  # Estética
  labs(title = "RDD com Dois Cutoffs: Notas vs Tamanho Predito",
       subtitle = "Regra italiana: 22 (financiamento) e 28 (obrigatório)",
       x = "Tamanho Predito da Turma (clsize_hat)",
       y = "Nota média (answers_math_std)",
       color = "Faixa de tamanho") +
  scale_color_manual(values = c("Abaixo de 22" = "#1f77b4",
                                "Entre 22 e 28" = "#ff7f0e",
                                "28 ou mais" = "#2ca02c")) +
  theme_minimal()

# 6. Adicionar linhas de regressão 
if (!is.null(linha_abaixo)) {
  p <- p + geom_line(data = linha_abaixo,
                     aes(x = clsize_hat, y = pred),
                     color = "#1f77b4", size = 1.2)
}

if (!is.null(linha_entre)) {
  p <- p + geom_line(data = linha_entre,
                     aes(x = clsize_hat, y = pred),
                     color = "#ff7f0e", size = 1.2)
}



# 7. Salvar gráfico
ggsave("output/rdd_dois_cutoffs.png", p, width = 10, height = 6, dpi = 300)


```
### 3.12 - Manipulação do running variable e consequências

Sim. Porque quando eles podem manipular tamanho de turmas para "escolher" qual o lado do cutoff que eles desejam, eles violam duas regras do RDD: Não manipulação e continuidade. A primeira é intuitiva, agentes não podem manipular onde eles estão colocados no cutoff. A segunda é um pouco menos, ela indica que as características dos alunos devem varia suavemente em torno do cutoff, algo que não acontece quando são manipulados.Se escolas com alunos de menor desempenho conseguem manter turmas menores (abaixo do cutoff) para ter mais atenção, ou se escolas com bons alunos permitem turmas maiores (acima do cutoff) para economizar recursos, temos seleção endógena.

Poderíamos combinar com variáveis instrumentais, usando a regra de Maimônides (clsize_hat) como instrumento para o tamanho REAL da turma (clsize_snv).Isso ocorre pois:

a. Ela é determinada administrativamente com cutoff claro.
b. Afeta o tamanho real da turma
c. Não pode ser alterada por professores, diretores ou alunos.
d. Ou seja é uma variação totalmente exógena.

#### DAG

                 Regra de Maimônides (clsize_hat)
                          │
                          ▼ (efeito causal)
                 Tamanho REAL da turma (clsize_snv)
                          │
             Manipulação de professores/diretores ←┐
                          │                       │
                          ▼ (confundimento)       │
                 Desempenho dos alunos            │
                          ▲                       │
                          │                       │
          Outros fatores (socioeconômicos, etc.) ─┘
          
Em que setas representam causalidade e o tracejado (dos outros fatores em direção a manipulação das turmas) indica viés. 

### 3.13 - Instrumentos

```{r Inst, cache=TRUE, results='asis'}

controles <- c(
  "female",
  "immigrants_broad",
  "dad_lowedu", "dad_midedu", "dad_highedu",
  "mom_unemp", "mom_housew", "mom_employed",
  "north", "centre", "south"
)

formula_iv <- as.formula(
  paste(
    "answers_math_std ~ clsize_snv +", 
    paste(controles, collapse = " + "),
    "| clsize_hat +", 
    paste(controles, collapse = " + ")
  )
)

# 2. Estimação IV
reg_maimonides <- ivreg(
  formula_iv,
  data = Maimonides_italia,
  subset = !is.na(answers_math_std),
  cluster = Maimonides_italia$cluster_id
)

summary(reg_maimonides)


```
 O tamanho predito da turma (clsize_hat) deriva da Regra de Maimônides,que define determinística e mecanicamente quando uma turma deve ser dividida em duas com base no número total de alunos.

 Essa regra não depende de atributos dos alunos ou da escola, mas apenas do ponto em que a capacidade é atingida, gerando variação exógena no tamanho da turma real (clsize_snv).

 Portanto, clsize_hat é um instrumento válido porque:

a. Relevância:
 
 Quando enrolment ultrapassa o cutoff da Regra de Maimônides, clsize_hat muda abruptamente -> forte correlação com clsize_snv.

2) Exogeneidade:
 
 A regra não depende das características dos alunos (habilidade, SES, origem) -> varia apenas por razões mecânicas.

3) Exclusion Restriction:

A regra afeta o desempenho apenas através do tamanho da turma real, não por outros canais.

Logo, clsize_hat é usado como instrumento em um estimador 2SLS:
   clsize_hat -> clsize_real
   clsize_real -> desempenho (answers_math_std)

Controles precisam entrar dos dois lados para manter ortogonalidade.

### 3.14 - Teoria Instrumentos

Interpretação do coeficiente IV:
 
  O coeficiente estimado no modelo IV representa o efeito causal local(LATE) do tamanho da turma real sobre o desempenho em matemática,usando a regra de Maimônides (clsize_hat) como instrumento. Ele mede o quanto a nota (answers_math_std) muda quando o tamanho da turma aumenta em 1 aluno, para os “compliers”, isto é, as turmas cujo tamanho realmente muda quando o cutoff da regra é ultrapassado.

  Efeito da manipulação dos testes pelos professores:

  Se professores tendem a ajustar notas, facilitar provas ou “inflar” desempenho em determinadas salas, isso cria um canal adicional entre tamanho da turma e nota — um canal que não passa pelo verdadeiro efeito pedagógico.

Exemplo:

  Turmas maiores -> mais pressão -> professores podem simplificar provas ou ajudar mais alunos -> notas artificialmente mais altas. 
  Ou o contrário:Turmas maiores -> mais caos -> professores corrigem mais duro → notas artificialmente mais baixas.

Assim, manipulação de notas gera uma violação do "exclusion restriction", pois o instrumento (clsize_hat) afeta Y (nota) também via comportamento do professor, não apenas via tamanho real da classe.

Maior manipulação em classes maiores porque:

 Classes maiores são mais vulneráveis a manipulação intencional ou inconsciente na avaliação.

O viés é para cima ou para baixo?

Para cima, notas são maiores nas turmas grandes um viés que empurra o coeficiente do tamanho da turma para cima ou seja, faz parecer que turmas maiores não prejudicam tanto quanto realmente prejudicam (ou até que “ajudam”).

### 3.15- Comparando Instrumentos

O sorteio do monitoramento talvez seja um pouco superior a Regra de Maiômides.Por definição uma veriável tem de ser relevante, exógena e satifazer a condição de exclusão. Vamos por partes:

Sorteio do Monitoramento - Relevante (afeta o monitoramento que reduz fraudes), exógeno (naturalmente aleatótio, perfeito) e exclusivo? Talvez, uma vez que somente afeta as notas através da redução de manipulação (mas podemos questionar se o monitoramento afeta o desempenho de alunos e professores).

Já Maiômides? Relevante (muito, afeta tamanhos de turma), exógeno (definido por regulamentação), exclusivo? Menos que o sorteio de monitoramento, pois o tamanho de turma pode não ser a única variável afetada, pode ser que alocação de professores e recursos seja afetada.

No geral ambos são relevantes, exógenos. A maior questão se coloca em relação a condição de exclusão. No geral podemos aceitar Maiômides como candidato razoável também mas o sorteio é superior.

### 3.16 Identificação (teórico)

Condição de ordem: L - K. Em que L é igual aos instrumentos, e K aos endógenos. Temos dois intrumentos (Maiômides, sorteio), L = 2; e duas variáveis endógenas (tamanho de turma e indícios de manipulação)

L - K, 2- 2 = 0

A condição indica modelo sobre identificado.

### 3.17 Identificação prático

```{r Identi, cache=TRUE,results='asis'}
# 1. Controles
controles <- "female + immigrants_broad + dad_lowedu + dad_midedu + dad_highedu +
              mom_unemp + mom_housew + mom_employed + north + centre + south"

# 2. Fórmula IV
form_iv <- as.formula(
  paste0(
    "answers_math_std ~ clsize_snv + our_CHEAT_math + ", controles,
    " | ",
    "clsize_hat + o_math + ", controles
  )
)

# 3. Estimação
reg_maimonides2 <- ivreg(
  form_iv,
  data = Maimonides_italia,
  cluster = "cluster_id"
)

summary(reg_maimonides2)

# Stargazer da comparação com o modelo anterior
stargazer(
  reg_maimonides,
  reg_maimonides2,
  type = "html",
  out = "iv.html",
  title = "IV: Interação entre Tamanho da Turma e Manipulação"
)

```
### 3.18 - Conclusão


a. Coeficiente do tamanho da turma (clsize_snv):
    - Modelo 1 (somente tamanho como endógeno): -0.006***
    
    - Modelo 2 (tamanho + manipulação como endógenas): -0.004***
    
 O efeito é negativo e estatisticamente significativo em ambos os casos, indicando que turmas maiores tendem a ter desempenho ligeiramente menor.

b. Coeficiente da manipulação (our_CHEAT_math):
    - Modelo 2: 3.317***
    -> Muito positivo e altamente significativo.
   
Isso mostra que a manipulação das notas pelos professores inflaciona artificialmente os resultados. Parte do efeito negativo do tamanho da turma era mascarado quando não controlávamos para manipulação.

c. Comparação entre os modelos:

   O coeficiente de clsize_snv diminui em magnitude ao incluir our_CHEAT_math. Isso indica que professores provavelmente manipulavam notas mais nas turmas maiores, aumentando artificialmente o desempenho médio. Sem controlar por manipulação, o efeito do tamanho da sala estava superestimado (em magnitude negativa) ou, dependendo da direção da manipulação, parcialmente mascarado.

d. Conclusão:

A inclusão da variável de manipulação permite isolar o efeito puramente causal do tamanho da turma sobre o desempenho. A manipulação tem impacto grande, positivo e estatisticamente robusto.Portanto, parte do efeito estimado do tamanho da turma em modelos simples é contaminado por alterações artificiais nas notas.




